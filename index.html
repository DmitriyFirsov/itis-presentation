<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
    <style>
        .line-3 {
            display: flex;
            flex-direction: row;
            align-items: center;
        }

        .line-3 > * {
            margin-right: 25px !important;
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <section>
                <div>
                    Introduction to JS, basic concepts
                </div>
                <aside class="notes">
                    Домашки 6 баллов
                    Интро - организационные моменты - рассказать про баллы (домашки - 6 баллов, возможно про код варс и
                    автомат)
                    - подумать ещё про баллы. Сказать про практику - задания - drag and drop и unit tests на компоненты.
                </aside>
            </section>
            <section>
                <div>Задача курса:</div>
                <div>
                    Создать аналог Trello:
                    <img src="images/trello.png">
                </div>
                <aside class="notes">
                    Страницы входа, регистрации, список проектов, добавление проекта, просмотр проекта,
                    добавление задачи, редактирование задачи, добавление пользователя в проект
                </aside>
            </section>
            <section>
                <p>Основные инструменты</p>
                <ul>
                    <li>react (create-react-app)</li>
                    <li>styled-components</li>
                    <li>jest</li>
                    <li>eslint, prettier</li>
                </ul>
            </section>
        </section>
        <section>
            <section>
                <h1>Браузеры</h1>
                <p>Что это такое и как они работают?</p>
                <aside class="notes">
                    Браузер - прикладное программное обеспечение для просмотра страниц, содержания веб-документов,
                    компьютерных файлов и их каталогов; управления веб-приложениями; а также для решения других задач. В
                    глобальной сети браузеры используют для запроса, обработки, манипулирования и отображения содержания
                    веб-сайтов. Многие современные браузеры также могут использоваться для обмена файлами с серверами
                    FTP, а также для непосредственного просмотра содержания файлов многих графических форматов (gif,
                    jpeg, png, svg), аудио- и видеоформатов (mp3, mpeg), текстовых форматов (pdf, djvu) и других файлов.
                </aside>
            </section>
            <section>
                <div>
                    Основные браузеры:
                </div>
                <ul>
                    <li>Chrome, Chromium, Yandex.Browser, Microsoft Edge, Opera - движок Blink, V8</li>
                    <li>Mozilla Firefox - движок Quantum (Gecko старая версия)</li>
                    <li>Internet Explorer - движок EdgeHTML (умри пожалуйста)</li>
                    <li>Safari - движок WebKit (macOS и iOS)</li>
                </ul>
                <aside class="notes">
                    Основные браузеры и их движки парсеры текста и исполнения js
                </aside>
            </section>
            <section>
                <h4>Кратко</h4>
                <img src="images/gode.jpg"/>
                <aside class="notes">
                    Чтобы нарисовать на экране результат работы нашего кода, браузеру нужно выполнить несколько этапов:

                    <ul>
                        <li>Сперва ему нужно скачать исходники.</li>
                        <li>Затем их нужно прочитать и распарсить.</li>
                        <li>После этого браузер приступает к рендерингу — отрисовке.</li>
                    </ul>

                    Каждый из процессов очень сложен, и мы не будем рассматривать их до мельчайших подробностей.

                    Мы лишь обратим внимание на те детали, которые необходимо знать фронтенд-разработчикам, чтобы лучше
                    понимать, почему разные решения по-разному влияют на производительность и скорость отрисовки.

                    Начнём по порядку.
                </aside>
            </section>
            <section>
                <h4>Получение ресурсов (Fetching)</h4>
                <img src="images/main-google-page.png">
                <div>Запросы на странице www.google.com</div>
                <aside class="notes">
                    Ресурсы браузер получает с помощью запросов к серверу. В ответ он может получить как, например,
                    данные в
                    виде json, так и картинки, видео, файлы стилей и скриптов.

                    Самый первый запрос к серверу — обычно запрос на получение HTML-страницы.
                </aside>
            </section>
            <section>
                <pre>
                    <code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;link href=&quot;/style.css&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;img src=&quot;/hello.jpg&quot; alt=&quot;Привет!&quot;&gt;
    &lt;script src=&quot;/index.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
                </pre>
                <div>структура простейшей страницы</div>
                <aside class="notes">
                    <div>
                        В коде страницы содержатся ссылки на другие ресурсы, которые браузер тоже запросит у сервера:
                    </div>
                    В примере браузер запросит:
                    <ul>
                        <li>файл стилей style.css</li>
                        <li>изображение hello.jpg</li>
                        <li>и скрипт index.js</li>
                    </ul>
                    Парсинг, Parsing
                    По мере того, как скачивается HTML-страница, браузер пытается её «прочитать» — распарсить.
                </aside>
            </section>
            <section>
                <h2>DOM</h2>
                <div>
                    DOM (Document Object Model) — абстрактное представление HTML-документа, с помощью которого браузер
                    может получать доступ к его элементам, изменять его структуру и оформление.
                </div>
                <aside class="notes">
                    Браузер работает не с текстом разметки, а с абстракциями над ним. Одна из таких абстракций,
                    результат парсинга HTML-кода, называется DOM.
                    DOM (Document Object Model) — абстрактное представление HTML-документа, с помощью которого браузер
                    может получать доступ к его элементам, изменять его структуру и оформление.
                    DOM — это дерево. Корень этого дерева — это элемент HTML, все остальные элементы — это дочерние
                    узлы.
                </aside>
            </section>
            <section style="margin-left: -150px">
                <div style="display: flex; flex-direction: row; align-items: center;">
                    <div style="margin-right: 40px">
                <pre>
                    <code style="width: 580px !important;">&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p class=&quot;text&quot;&gt;Hello world&lt;/p&gt;
    &lt;img src=&quot;/hello.jpg&quot; alt=&quot;Привет!&quot;&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
                </pre>
                        <div>HTML</div>
                    </div>
                    <div>
                <pre>
                    html
        ____________|________
        |                    |
      head                  body
    ____|____              ___|___
    |       |             |       |
    meta   title          p      img
            |             |
          "Hello"    "Hello world"
                </pre>
                        <div>DOM</div>
                    </div>
                </div>
                <aside class="notes">
                    <p>
                        Пока браузер парсит документ и строит DOM, он натыкается на элементы типа img, link, script,
                        которые
                        содержат ссылки на другие ресурсы.
                    </p>
                    <p>
                        Если ресурс неблокирующий (например, изображение), браузер запрашивает его параллельно с
                        парсингом
                        оставшейся части документа. Блокирующие ресурсы (например, скрипты) приостанавливают обработку
                        до
                        своей полной загрузки.
                    </p>
                </aside>
            </section>
            <section>
                <pre><code>// script.js
const image = document.getElementById("image")</code>
                </pre>
                <div style="font-size: 0.8em"> нахождение элемента на странице по id</div>
                <pre>
                    <code>&lt;body&gt;
  &lt;img src=&quot;/hello.jpg&quot; alt=&quot;Hello world&quot; id=&quot;image&quot;&gt;
  &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;</code>
                </pre>
                <div style="font-size: 0.8em"> image = undefined</div>
                <pre>
                    <code>&lt;body&gt;
  &lt;img src=&quot;/hello.jpg&quot; alt=&quot;Hello world&quot; id=&quot;image&quot;&gt;
  &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;</code>
                </pre>
                <div style="font-size: 0.8em"> image = &lt;image&gt</div>
                <aside class="notes">
                    <p>
                        Мы можем указывать браузеру, как именно ему следует запрашивать некоторые ресурсы, например,
                        скрипты. Это может быть полезно, когда в скрипте мы собираемся работать с элементами, которые
                        находятся в разметке после тега script:
                    </p>
                    <p>
                        В в первом случае image === undefined, потому что браузер успел распарсить только часть
                        документа до
                        этого тега script.
                    </p>
                    <p>
                        А во втором всё в порядке, изображение найдётся
                    </p>
                </aside>
            </section>
            <section>
            <pre>
                <code data-line-numbers="2|3">&lt;body&gt;
  &lt;script src=&quot;script.js&quot; defer&gt;&lt;/script&gt;
  &lt;script src=&quot;script.js&quot; async&gt;&lt;/script&gt;
  &lt;img src=&quot;/hello.jpg&quot; alt=&quot;Hello world&quot; id=&quot;image&quot;&gt;
&lt;/body&gt;</code>
            </pre>
                <aside class="notes">
                    <p>И в этом тоже порядок, атрибут defer скажет браузеру продолжать парсить страницу и выполнить
                        скрипт потом</p>
                    <p>async говорит браузеру загрузить и распарсить скрипт когда появится время</p>
                </aside>
            </section>
            <section>
                <h2>CSSOM</h2>
                <p>
                    CSSOM (CSS Object Model) — по аналогии с DOM, представление стилевых правил в виде дерева
                </p>
                <aside class="notes">
                    <p>
                        Когда браузер находит элемент link, который указывает на файл стилей, браузер скачивает и парсит
                        его.
                        Результат парсинга CSS-кода — CSSOM.
                    </p>
                    <p>
                        CSSOM (CSS Object Model) — по аналогии с DOM, представление стилевых правил в виде дерева.
                    </p>
                </aside>
            </section>
            <section style="margin-left: -150px">
                <div class="line-3">
            <pre>
                <code>&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p class=&quot;text&quot;&gt;Hello world&lt;/p&gt;
    &lt;img src=&quot;/hello.jpg&quot;
alt=&quot;Привет!&quot;&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
            </pre>
                    <pre>
                <code>body {
  font-size: 14px;
}
.text {
  color: red;
}
img {
  max-width: 100%;
}</code>
            </pre>
                    <pre>
             body
      (font-size: 14px)
      ________|_________
      |                 |
    .text              img
(color: red)    (max-width: 100%)</pre>
                </div>
                <aside class="notes">
                    <p>
                        документ - стили - CSSOM
                    </p>
                    <p>
                        Чтение стилей приостанавливает чтение кода страницы. Поэтому рекомендуется в самом начале
                        отдавать только критичные стили — которые есть на всех страницах и конкретно на этой. Так мы
                        уменьшаем время ожидания, пока «страница загрузится».
                    </p>
                </aside>
            </section>
            <section>
                <h2>Render Tree</h2>
                <pre style="margin-left: 250px; border: none; box-shadow: none">
               html
                |
              body
        (font-size: 14px)
        ________|________
        |               |
      p.text           img
    (color: red)  (max-width: 100%)
        |
  "Hello world"</pre>
                <aside class="notes">
                    <p>
                        После того, как браузер составил DOM и CSSOM, он объединяет их в общее дерево рендеринга —
                        Render Tree.
                    </p>
                    <p>
                        Render Tree — в разных движках это дерево называется по разному
                    </p>
                </aside>
            </section>
            <section>
                <p>Общая схема парсинга</p>
                <img src="images/render.webp">
            </section>
            <section>
                <div>Глобальное и инкрементальное вычисление позиции и размеров, Layout</div>
                <div class="r-hstack">
                    <img src="images/malchishnik-v-vegase-kazino-formuly-mem.jpeg">
                    <img src="images/blondlady-1.jpg">
                </div>
                <aside class="notes">
                    <br>
                    После того как у браузера появилось дерево рендеринга (Render Tree), он начинает «расставлять»
                    элементы на странице. Этот процесс называется Layout.

                    <br>
                    Чтобы понимать, где какой элемент должен находиться и как он влияет на расположение других
                    элементов, браузер рассчитывает размеры и положение каждого рекурсивно.

                    <br>
                    Расчёт начинается от корневого элемента дерева рендеринга, его размеры равны размеру вьюпорта. Далее
                    браузер переходит поочерёдно к каждому из дочерних элементов.

                    <br>
                    Важно помнить, что Layout построен на поточной модели компоновки. Это значит, что если элементы не
                    влияют на расположение и размеры других элементов, то их положение и размеры можно просчитать за
                    один подход.

                    <br>
                    Именно поэтому при вёрстке макетов рекомендуется «находиться в потоке» — чтобы браузеру не
                    приходилось несколько раз пересчитывать один и тот же элемент, так страница отрисовывается быстрее.
                    <br>
                    Глобальный Layout — это процесс просчёта всего дерева полностью, то есть каждого элемента.
                    Инкрементальный — просчитывает только часть.
                    <br>
                    Глобальный Layout запускается, например, при изменении размера окна, потому что браузеру требуется
                    подогнать всю страницу под новый размер экрана. Это очень дорогой процесс.
                    <br>
                    Инкрементальный Layout запускает пересчёт только «грязных» элементов.
                </aside>
            </section>
            <section>
                <div>«Грязные» элементы</div>
                <img src="images/elements.webp">
                <aside class="notes">
                    <p>
                        Это те элементы, которые были изменены, и их дочерние элементы.
                    </p>
                    <p>
                        Если мы как-то поменяли блок, то браузер перерисует его и его детей, потому что их положение и
                        размеры могут зависеть от родителя.
                    </p>
                    <p>
                        Дальше браузер приступает к, собственно, отрисовке.
                    </p>
                </aside>
            </section>
            <section>
                <div>Непосредственно отрисовка, Paint</div>
                <div>TODO: найти сюда какую-то картинку</div>
                <aside class="notes">
                    <p>
                        Во время отрисовки (Paint) браузер наполняет пиксели на экране нужными цветами в зависимости от
                        того, что в конкретном месте должно быть нарисовано: текст, изображение, цвет фона, тени, рамки
                        и т.
                        д.
                    </p>
                    <p>
                        Отрисовка тоже бывает глобальной и инкрементальной. Чтобы понять, какую часть вьюпорта надо
                        перерисовать, браузер делит весь вьюпорт на прямоугольные участки. Логика тут та же, как и в
                        Layout
                        — если изменения ограничены одним участком, то пометится «грязным» и перерисуется лишь он.
                        Отрисовка — это самый дорогой процесс из всех, что мы уже перечислили.
                    </p>
                </aside>
            </section>
            <section>
                <h3>Порядок отрисовки</h3>
                <ul>
                    <li>background-color</li>
                    <li>background-image</li>
                    <li>border</li>
                    <li>children</li>
                    <li>outline</li>
                </ul>
                <aside class="notes">
                    В общих чертах, отрисовка начинается с заднего плана и постепенно переходит к переднему
                </aside>
            </section>
            <section>
                <div>CPU и композитинг</div>
                <img src="images/composing.webp">
                <aside class="notes">
                    <p>
                        И Layout, и Paint работают за счёт CPU (central process unit), поэтому относительно медленные.
                        Плавные анимации при таком раскладе невероятно дорогие.
                    </p>
                    <p>
                        Для плавных анимаций в браузерах предусмотрен композитинг (Compositing).
                    </p>
                    <p>
                        Композитинг — это разделение содержимого страницы на «слои», которые браузер будет
                        перерисовывать.
                        Эти слои друг от друга не зависят, из-за чего изменение элемента в одном слое не затрагивает
                        элементы из других слоёв, и перерисовывать их становится не нужно.
                    </p>
                    <p>
                        Именно из-за разнесения элементов по разным композиционным слоям свойство transform не так
                        сильно
                        нагружает браузер. Поэтому чтобы анимации не тормозили, их рекомендуется делать с применением
                        transform и opacity.
                    </p>
                    <p>
                        Применение таких свойств, как, например, transform, «выносит» элемент на отдельный композитный
                        слой, где положение элемента не зависит от других и не влияет на них.
                    </p>
                </aside>
            </section>
            <section>
                <div>Перерисовка, Reflow (relayout) и Repaint</div>
                <div>TODO: вставить какую-то картинку</div>
                <aside class="notes">
                    <p>
                        Процесс отрисовки — циклический. Браузер перерисовывает экран каждый раз, когда на странице
                        происходят какие-то изменения.
                    </p>
                    <p>
                        Если, например, в DOM-дереве добавился новый узел, или изменился текст, то браузер построит
                        новое
                        дерево рендеринга и запустит вычисление позиции и отрисовку заново.
                    </p>
                    <p>
                        Один цикл обновления — это animation frame.
                    </p>
                    <p>
                        Зная «расписание отрисовки» браузера, мы можем «предупредить» его, что хотим запустить какую-то
                        анимацию на каждый новый фрейм. Это можно сделать с помощью requestAnimationFrame.
                    </p>
                </aside>
            </section>
            <section>
                <pre>
                    <code class="language-js" data-line-numbers="|5-7|9">const animate = () => {
  // Код анимации
}

// 60 раз в 1000 миллисекунд, приблизительно 16 мс.
const intervalMS = 1000 / 60;
setInterval(animate, intervalMS);

window.requestAnimationFrame(animate);</code>
                </pre>
                <aside class="notes">
                    <p>
                        animate функция запускает новый кадр анимации: обновляет какое-то свойство или перерисовывает
                        canvas.
                    </p>
                    <p>
                        Если мы хотим добиться плавной анимации, используя функцию animate, мы должны обеспечить в
                        среднем
                        60 обновлений экрана за секунду (60 fps — frames per second).
                    </p>
                    <p>
                        Это можно сделать топорно, через интервал
                    </p>
                    <p>
                        Либо использовать window.requestAnimationFrame:
                    </p>
                    <p>
                        Интервалы не всегда запускаются в нужный момент. setInterval не учитывает, на какой стадии
                        отрисовки находится страница, и в итоге кадры отрисовки могут быть рваными или дёрганными
                    </p>
                    <p>
                        С интервалом анимация может быть рваной, потому что перерисовка может быть запущена в
                        неподходящее время.
                    </p>
                    <p>
                        А если вкладка была неактивна, то интервал может «попытаться догнать время», и несколько кадров
                        запустятся разом
                    </p>
                    <p>
                        С requestAnimationFrame анимация плавнее, потому что браузер знает, что в следующем фрейме надо
                        запустить новый кадр анимации.
                    </p>
                    <p>
                        Она не гарантирует, что анимация будет запущена строго раз в 16 мс, но значение будет достаточно
                        близким.
                    </p>
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h1>HTML</h1>
                <aside class="notes">
                    HTML — язык разметки для создания структуры веб-страницы и представления контента. Благодаря
                    разметке браузер знает в каком порядке отображать элементы, и что они значат.
                </aside>
            </section>
            <section>
                <p>Структура тегов</p>
                <pre>
                    <code>&lt;тег атрибут=&quot;значение&quot;&gt;контент&lt;/тег&gt;
&lt;тэг&gt;
&lt;тег атрибут=&quot;значение&quot;&gt;контент&lt;тег&gt;контент&lt;/тег&gt;&lt;/тег&gt;</code>
                </pre>
            </section>
            <section>
                Структура HTML
                                <pre>
                    <code data-line-numbers="|1|2,12|3,7|4|5,10|6|8,11|9|">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;link href=&quot;/style.css&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;script src=&quot;/index.js&quot;&gt;&lt;/script&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;img src=&quot;/hello.jpg&quot; alt=&quot;Привет!&quot;&gt;
    &lt;script src=&quot;/index1.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
                </pre>
                <aside class="notes">
                    <ul>
                        <li>Структура документа</li>
                        <li>Инструкция говорит о том что это современный html документ</li>
                        <li>Начало документа</li>
                        <li>Заголовок</li>
                        <li>Подгрузка стилей из файла</li>
                        <li>Загрузка скрипта</li>
                        <li>Заголовок документа - показывается в названии вкладки</li>
                        <li>Тело документа</li>
                        <li>Картинка</li>
                    </ul>
                </aside>
            </section>
            <section>
               <a href="https://doka.guide/html/">Дока гайд</a>
            </section>
        </section>
        <section>
            <section>
                <h1>CSS</h1>
            </section>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>
</body>
</html>
